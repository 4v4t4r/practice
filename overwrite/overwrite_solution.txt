To solve:
Overwrite the "key" variable with the proper key.

GDB Peda:
1. Break main
2. step into first function (func)
3. stepover down to <gets>
4. Break *func+35 for easy return
5. On the gets call, notice the guessed argument. this is the memory address of our input
6. pattern create 64 to make a string pattern of 64 bytes (we just guess the 64)
7. next and input the pattern
8. Notice we now land on a cmp of ebp+0x8 with the correct key value of 0xcafebabe
9. We must overflow out input so that it overwrites ebp+0x8 and allows us to input the correct key!
10. We can view the address (and value) of ebp+0x8 with x $ebp+0x8
11. To find the distance from our input to ebp+0x8 we telescope 25 to view the last 25 stack pushes
12.Find the proper address and then due an offset search fo the pattern it holds
13. pattern offset AAGAAcAA2AAH -- offset is 52 therefor it's 52 bytes from our input.
14. Finally, we overflow the buffer with 52bytes so that we can write the correct key to to the proper location (over the key variable)
15. perl -e 'print "A"x52 . "\xbe\xba\xfe\xca"' | ./overflow (the location is backwards because it's little endian
16. Kali has smash stacking protection so you WILL get an error. But that's normal. If you want to test this you can solve the original challenge at pwnable.kr:9000

Use my bufoverflow_remote.py template from my "tools" repo for easy payload deploy!
